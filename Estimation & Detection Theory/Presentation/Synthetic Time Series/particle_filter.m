function [xhk, pf] = particle_filter(sys,obs, yk, pf, resampling_strategy)% Inputs:% sys  = function handle to process equation% yk   = observation vector at time k (column vector)% pf   = structure with the following fields%   .k                = iteration number%   .Ns               = number of particles%   .w                = weights   (Ns x T)%   .particles        = particles (nx x Ns x T)%   .gen_x0           = function handle of a procedure that samples from the initial pdf p_x0%   .p_yk_given_xk    = function handle of the observation likelihood PDF p(y[k] | x[k])%   .gen_sys_noise    = function handle of a procedure that generates system noise% resampling_strategy = resampling strategy. Set it either to %                       'multinomial_resampling' or 'systematic_resampling'% Outputs:% xhk   = estimated state% pf    = the same structure as in the input but updated at iteration kk = pf.k;if k == 1   error('error: k must be an integer greater or equal than 2');end%% Initialize variablesNs = pf.Ns;                              % number of particlesnx = size(pf.particles,1);               % number of stateswkm1 = pf.w(:, k-1);                     % weights of last iterationif k == 2   for i = 1:Ns                          % simulate initial particles      pf.particles(:,i,1) = pf.gen_x0(); % at time k=1   end      wkm1 = repmat(1/Ns, Ns, 1);           % all particles have the same weightend%%% The importance sampling function:% PRIOR: (this method is sensitive to outliers)   THIS IS THE ONE USED HERE% q_xk_given_xkm1_yk = pf.p_xk_given_xkm1;% OPTIMAL:% q_xk_given_xkm1_yk = q_xk_given_xkm1^i_yk;% Note this PDF can be approximated by MCMC methods: they are expensive but % they may be useful when non-iterative schemes fail%% Separate memoryxkm1 = pf.particles(:,:,k-1); % extract particles from last iteration;xk   = zeros(size(xkm1));     % = zeros(nx,Ns);wk   = zeros(size(wkm1));     % = zeros(Ns,1);m_xkm1=mean(xkm1) ;cov_xkm1=cov(xkm1) ;fstate= @(x) sys(k, x , 0);hmeas= @(x) obs(k, x, 0) ;Q=0.1; %Q: process noise covariance  R=0.1; %R: measurement noise covariance[m_xk,P_xk] = ukf(fstate, m_xkm1, cov_xkm1, hmeas, yk, Q, R);for i = 1:Ns   % xk(:,i) = sample_vector_from q_xk_given_xkm1_yk given xkm1(:,i) and yk   % Using the PRIOR PDF: pf.p_xk_given_xkm1   %xk(:,i) = sys(k, xkm1(:,i), pf.gen_sys_noise());   u = normrnd(m_xk,sqrt(P_xk));   xk(:,i)=u;     % weights (when using the PRIOR pdf):   wk(i) = wkm1(i)*pf.p_yk_given_xk(k, yk, xk(:,i));end;%% Normalize weight vectorwk = wk./sum(wk);%% Calculate effective sample sizeNeff = 1/sum(wk.^2);%% Resampling!!!% remove this condition and sample on each iteration:% [xk, wk] = resample(xk, wk, resampling_strategy);%if you want to implement the bootstrap particle filterresample_percentaje = 0.50;Nt = resample_percentaje*Ns;if Neff < Nt   disp("Resampling...")   [xk, wk] = resample(xk, wk, resampling_strategy);   % {xk, wk} is an approximate discrete representation of p(x_k | y_{1:k})end%% Compute estimated statexhk = zeros(nx,1);for i = 1:Ns;   xhk = xhk + wk(i)*xk(:,i);end%% Store new weights and particlespf.w(:,k) = wk;pf.particles(:,:,k) = xk;return; % bye, bye!!!